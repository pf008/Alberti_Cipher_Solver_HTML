<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Alberti Polyalphabetic Cracker (Segmented)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Custom style for monospaced output */
    #bestResult, #results div {
      white-space: pre-wrap;
      word-break: break-all;
    }
    .loading-spinner {
        border: 4px solid rgba(0, 0, 0, 0.1);
        border-top: 4px solid #3b82f6;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        animation: spin 1s linear infinite;
    }
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body class="bg-gray-50 min-h-screen p-4 sm:p-6 font-sans antialiased">
  <div class="max-w-4xl mx-auto">
    <header class="text-center mb-6">
      <h1 class="text-4xl font-extrabold text-indigo-700">Alberti Segment Cracker (Hill Climbing)</h1>
      <p class="mt-2 text-gray-600">Finds the **Inner Disk Permutation** and the **Indicator Letter** for an Alberti cipher using segmented shifts.</p>
    </header>

    <main class="bg-white p-6 rounded-xl shadow-xl border border-gray-100">
      <div class="mb-4">
        <label for="ciphertext" class="block text-sm font-medium text-gray-700 mb-1">Ciphertext (UPPERCASE for Indicators, lowercase for Cipher chars):</label>
        <textarea id="ciphertext" rows="4" class="w-full p-3 border border-gray-300 rounded-lg font-mono text-base resize-none focus:ring-indigo-500 focus:border-indigo-500 transition duration-150" placeholder="e.g. 'AhtabxmRcgashDfuiomaoWbhaqdatd...'"></textarea>
      </div>

      <div class="flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-4 mb-6">
        <button onclick="startCracking()" id="startBtn" class="flex items-center justify-center px-6 py-2 bg-green-600 text-white font-bold rounded-lg hover:bg-green-700 transition duration-150 shadow-md">
          Start Cracking
        </button>
        <button onclick="stopCracking()" id="stopBtn" class="flex items-center justify-center px-6 py-2 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700 transition duration-150 shadow-md hidden">
          Stop
        </button>
        <div id="loadingIndicator" class="hidden loading-spinner self-center"></div>
      </div>
      
      <div id="statusMessage" class="mt-2 text-sm text-yellow-600">Loading N-gram files...</div>

      <h2 class="mt-6 text-xl font-semibold text-indigo-600 border-b pb-2">Best Result</h2>
      <div id="bestResult" class="mt-2 p-3 bg-indigo-50 rounded-lg font-mono text-sm text-gray-800">
        <span class="font-bold">Initial Key:</span> ABCDEFGHIJKLMNOPQRSTUVWXYZ<br>
        <span class="font-bold">Indicator:</span> ?<br>
        <span class="font-bold">Score:</span> 0.00<br>
        <span class="font-bold">Plaintext (Indicators Included):</span> Awaiting decryption...
      </div>

      <h2 class="mt-6 text-xl font-semibold text-indigo-600 border-b pb-2">Top 5 Candidate Keys</h2>
      <div id="results" class="mt-2 space-y-2 font-mono text-xs">
        <p class="text-gray-500 italic">Results will appear here as the cracker runs.</p>
      </div>
    </main>
  </div>

  <script>
    // --- Configuration and State ---
    const OUTER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const OUTER_ALPHABET_LOWER = 'abcdefghijklmnopqrstuvwxyz'; 
    let cracking = false;
    let topCandidates = [];
    let quadgramMap = {}, trigramMap = {}, bigramMap = {};
    let dictionarySet = new Set();
    let isDataLoaded = false;
    
    const STATUS = document.getElementById('statusMessage');

    // --- Utility Functions ---

    /** Rotates the Outer Alphabet to generate the alignment for a given shift (0-25). */
    const ROTATIONS = Array.from({ length: 26 }, (_, i) => OUTER_ALPHABET.slice(i) + OUTER_ALPHABET.slice(0, i));

    async function fetchWithRetry(url, maxRetries = 3) {
        for (let attempt = 0; attempt < maxRetries; attempt++) {
            try {
                const response = await fetch(url);
                if (response.ok) {
                    return response;
                }
                throw new Error(`HTTP error! status: ${response.status}`);
            } catch (error) {
                if (attempt < maxRetries - 1) {
                    const delay = Math.pow(2, attempt) * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                } else {
                    throw new Error(`Failed to load ${url} after ${maxRetries} attempts.`);
                }
            }
        }
    }

    // --- Data Loading Functions ---

    async function loadFrequencies(file, map) {
      // Logic for loading frequency files from quadgrams.txt, etc.
      try {
        const res = await fetchWithRetry(file);
        const text = await res.text();
        const lines = text.trim().split('\n');
        const counts = {};
        let total = 0;
        
        for (let line of lines) {
          const parts = line.trim().split(/\s+/);
          if (parts.length === 2) {
              const [gram, countStr] = parts;
              const count = parseFloat(countStr);
              if (!isNaN(count)) {
                  counts[gram.toUpperCase()] = count;
                  total += count;
              }
          }
        }
        
        for (let gram in counts) {
          map[gram] = Math.log10(counts[gram] / total);
        }
        STATUS.textContent = `Loaded ${file} successfully.`;
      } catch (error) {
        STATUS.textContent = `ERROR loading ${file}: ${error.message}. Please ensure the file exists.`;
        throw error;
      }
    }

    async function loadDictionary(file) {
      try {
        const res = await fetchWithRetry(file);
        const words = (await res.text()).split(/\s+/).filter(w => w.length > 0);
        for (let word of words) {
          dictionarySet.add(word.trim().toLowerCase());
        }
        STATUS.textContent = `Loaded ${file} successfully. Total words: ${dictionarySet.size}.`;
      } catch (error) {
        STATUS.textContent = `ERROR loading ${file}: ${error.message}. Please ensure the file exists.`;
        throw error;
      }
    }

    async function loadAllScoringData() {
        document.getElementById('loadingIndicator').classList.remove('hidden');
        try {
            await Promise.all([
                loadFrequencies('quadgrams.txt', quadgramMap),
                loadFrequencies('trigrams.txt', trigramMap),
                loadFrequencies('bigrams.txt', bigramMap),
                loadDictionary('dictionary.txt')
            ]);
            isDataLoaded = true;
            STATUS.textContent = "All files loaded. Ready to crack!";
        } catch (error) {
            isDataLoaded = false;
            STATUS.textContent = "CRITICAL ERROR: Failed to load one or more required data files. Check console for details.";
        } finally {
            document.getElementById('loadingIndicator').classList.add('hidden');
        }
    }

    // --- Alberti Decryption Logic (Segmented) ---

    /** * Decrypts ciphertext using the segmented Alberti mechanism found in your uploaded file.
     * @param {string} ciphertext - The text with UPPERCASE indicators and lowercase cipher chars.
     * @param {string} innerKey - The 26-char permutation (Inner Disk).
     * @param {string} fixedIndicator - The assumed fixed indicator letter (e.g., 'T').
     * @returns {{displayText: string, scoreText: string}}
     */
    function decodeAlberti(ciphertext, innerKey, fixedIndicator) {
      let plaintext = '';
      let scoreablePlaintext = '';
      let i = 0;
      
      // Fixed index of the indicator on the inner key
      const indicatorIndex = innerKey.indexOf(fixedIndicator);

      if (indicatorIndex === -1) {
          // If the fixed indicator is not in the key, decryption is impossible.
          return { displayText: 'ERROR: Indicator not in key', scoreText: '' }; 
      }

      while (i < ciphertext.length) {
        const char = ciphertext[i];

        if (char >= 'A' && char <= 'Z') {
          // 1. Indicator Letter (UPPERCASE)
          const indicatorCap = ciphertext[i++];
          
          plaintext += indicatorCap; // Include indicator in display text
          
          // Find the new segment shift based on the indicator letter
          const capIndex = OUTER_ALPHABET.indexOf(indicatorCap); // Position of indicator on Outer Disk
          
          // Calculate shift: distance from Outer[IndicatorCap] to Inner[fixedIndicator]
          // The decrypted character is the one on the Outer Disk that aligns with the Inner Disk's position.
          // This calculates the necessary rotation of the OUTER disk to align OUTER[capIndex] with INNER[indicatorIndex].
          // Effectively, it calculates the Vigenere shift required for this segment.
          const shift = (capIndex - indicatorIndex + 26) % 26;
          const rotatedOuter = ROTATIONS[shift];
          
          // Now, decrypt the segment until the next indicator or end of text
          let segmentEnd = i;
          while (segmentEnd < ciphertext.length && !(ciphertext[segmentEnd] >= 'A' && ciphertext[segmentEnd] <= 'Z')) {
            segmentEnd++;
          }
          
          const segment = ciphertext.substring(i, segmentEnd);
          
          for (let ch of segment) {
            if (ch >= 'a' && ch <= 'z') {
                const cipherCharUpper = ch.toUpperCase();
                // 1. Find the position of the cipher char on the Inner Disk (keyAlphabet)
                const innerPos = innerKey.indexOf(cipherCharUpper);
                
                if (innerPos !== -1) {
                    // 2. The plaintext character is the one at the same position on the Rotated Outer Disk
                    const decryptedChar = rotatedOuter[innerPos];
                    plaintext += decryptedChar;
                    scoreablePlaintext += decryptedChar; 
                } else {
                    plaintext += '?';
                }
            } else {
                // Non-alphabetic chars (spaces, etc.)
                plaintext += ch;
            }
          }
          
          i = segmentEnd; // Move pointer past the decrypted segment

        } else {
            // Non-alphabetic characters (if they aren't indicators, they are just copied)
            plaintext += char;
            i++;
        }
      }
      
      return { displayText: plaintext, scoreText: scoreablePlaintext };
    }

    // --- Scoring Functions (Work on the scoreablePlaintext) ---

    const DEFAULT_SCORE = -10.0; // Use a high penalty for unknown grams

    function scoreNgrams(text, map, size) {
      let score = 0;
      for (let i = 0; i + size <= text.length; i++) {
        const gram = text.substr(i, size).toUpperCase();
        score += map[gram] || DEFAULT_SCORE;
      }
      return score;
    }

    function scoreDictionary(text) {
      const words = text.toLowerCase().split(/[^a-z]+/);
      let count = 0;
      for (let w of words) {
        if (dictionarySet.has(w) && w.length > 2) count++;
      }
      return count * 15.0; // Dictionary matches are highly valuable
    }

    function fullScore(text) {
      // Quadgrams are the most reliable metric, hence the highest weight (0.5)
      const q = scoreNgrams(text, quadgramMap, 4);
      const t = scoreNgrams(text, trigramMap, 3);
      const b = scoreNgrams(text, bigramMap, 2);
      const d = scoreDictionary(text);
      
      return (0.5 * q) + (0.3 * t) + (0.1 * b) + (0.1 * d);
    }

    // --- Hill Climbing Core Functions ---

    function generateRandomKey() {
      const letters = OUTER_ALPHABET.split('');
      for (let i = letters.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [letters[i], letters[j]] = [letters[j], letters[i]];
      }
      return letters.join('');
    }

    function generateNeighbors(key, numNeighbors = 50) {
      const neighbors = [];
      for (let i = 0; i < numNeighbors; i++) {
        const arr = key.split('');
        const a = Math.floor(Math.random() * 26);
        let b = Math.floor(Math.random() * 26);
        while (a === b) { b = Math.floor(Math.random() * 26); }
        
        [arr[a], arr[b]] = [arr[b], arr[a]];
        neighbors.push(arr.join(''));
      }
      return neighbors;
    }

    /** Updates the list of top 5 candidates, which includes the fixedIndicator that yielded the best score. */
    function updateTopCandidates(candidate) {
      const existingIndex = topCandidates.findIndex(c => c.key === candidate.key && c.indicator === candidate.indicator);
      
      if (existingIndex !== -1) {
          if (candidate.score > topCandidates[existingIndex].score) {
               topCandidates[existingIndex] = candidate;
          }
      } else {
          topCandidates.push(candidate);
      }
      
      topCandidates.sort((a, b) => b.score - a.score);
      if (topCandidates.length > 5) topCandidates.pop();

      // Update the main best result display
      const best = topCandidates[0];
      if (best) {
          document.getElementById('bestResult').innerHTML = 
              `<span class="font-bold">Initial Key:</span> ${best.key}<br>` +
              `<span class="font-bold">Indicator:</span> ${best.indicator}<br>` +
              `<span class="font-bold">Score:</span> ${best.score.toFixed(4)}<br>` +
              `<span class="font-bold">Plaintext (Indicators Included):</span> ${best.text.displayText.slice(0, 150)}...`;
      }

      // Update the top candidates list
      const resultsDiv = document.getElementById('results');
      resultsDiv.innerHTML = topCandidates.map(c =>
        `<div><span class="text-green-700">${c.score.toFixed(4)}</span> | Ind: ${c.indicator} | Key ${c.key.slice(0, 15)}... | ${c.text.displayText.slice(0, 50)}...</div>`
      ).join('');
    }

    // --- Main Cracking Loop ---

    async function startCracking() {
      const ciphertext = document.getElementById('ciphertext').value.trim();
      const minLength = 30; // Reduced minimum length for flexibility
      if (ciphertext.replace(/[^a-zA-Z]/g, '').length < minLength) {
        STATUS.textContent = `Error: Ciphertext (non-space characters) is too short for Hill Climbing. Please use at least ${minLength} characters.`;
        return;
      }
      
      document.getElementById('startBtn').disabled = true;

      if (!isDataLoaded) {
          STATUS.textContent = "Loading N-gram and Dictionary files...";
          await loadAllScoringData();
          if (!isDataLoaded) { 
               document.getElementById('startBtn').disabled = false;
               return;
          }
      }

      // 1. Initialize Cracking State
      document.getElementById('startBtn').classList.add('hidden');
      document.getElementById('stopBtn').classList.remove('hidden');
      document.getElementById('loadingIndicator').classList.remove('hidden');
      document.getElementById('results').innerHTML = '';
      topCandidates = [];
      cracking = true;
      let iterations = 0;

      // Start with a randomized key and an initial best result
      let currentKey = generateRandomKey();
      let currentBestCandidate = { key: currentKey, indicator: 'A', score: -Infinity, text: { displayText: 'N/A', scoreText: '' } };

      // Initialize by testing all 26 indicators for the first random key
      for (const ind of OUTER_ALPHABET) {
          const decoded = decodeAlberti(ciphertext, currentKey, ind);
          const score = fullScore(decoded.scoreText);
          if (score > currentBestCandidate.score) {
              currentBestCandidate = { key: currentKey, indicator: ind, score: score, text: decoded };
          }
      }
      updateTopCandidates(currentBestCandidate);


      // 2. The Hill Climbing Loop
      function loop() {
        if (!cracking) {
            document.getElementById('loadingIndicator').classList.add('hidden');
            document.getElementById('startBtn').disabled = false;
            STATUS.textContent = `Cracking stopped after ${iterations} iterations.`;
            return;
        }
        
        iterations++;
        
        const neighbors = generateNeighbors(currentBestCandidate.key, 100); 
        let bestNeighborCandidate = currentBestCandidate; // Start comparison with the current best solution

        // Iterate through all neighbors
        for (const nKey of neighbors) {
            // For each neighbor key, test all 26 possible indicator letters
            for (const ind of OUTER_ALPHABET) {
                const decoded = decodeAlberti(ciphertext, nKey, ind);
                const score = fullScore(decoded.scoreText);

                if (score > bestNeighborCandidate.score) {
                    bestNeighborCandidate = { key: nKey, indicator: ind, score: score, text: decoded };
                }
            }
        }
        
        // 3. Update or Restart
        if (bestNeighborCandidate.score > currentBestCandidate.score) {
            currentBestCandidate = bestNeighborCandidate;
            STATUS.textContent = `Iteration ${iterations}: Improved score to ${currentBestCandidate.score.toFixed(4)}. Climbing...`;
        } else {
            // Random restart to avoid local maxima
            currentKey = generateRandomKey();
            // Test all indicators for the new random key to find the best start
            let restartCandidate = { key: currentKey, indicator: 'A', score: -Infinity, text: { displayText: 'N/A', scoreText: '' } };
            for (const ind of OUTER_ALPHABET) {
                const decoded = decodeAlberti(ciphertext, currentKey, ind);
                const score = fullScore(decoded.scoreText);
                if (score > restartCandidate.score) {
                    restartCandidate = { key: currentKey, indicator: ind, score: score, text: decoded };
                }
            }
            currentBestCandidate = restartCandidate;
            STATUS.textContent = `Iteration ${iterations}: Stuck or no improvement. Random restart. New best score: ${currentBestCandidate.score.toFixed(4)}.`;
        }

        updateTopCandidates(currentBestCandidate);
        
        setTimeout(loop, 0); // Non-blocking loop
      }

      loop();
    }

    function stopCracking() {
      cracking = false;
      document.getElementById('startBtn').classList.remove('hidden');
      document.getElementById('stopBtn').classList.add('hidden');
      document.getElementById('loadingIndicator').classList.add('hidden');
    }
    
    // Initial data load on startup
    document.addEventListener('DOMContentLoaded', loadAllScoringData);
  </script>
</body>
</html>
